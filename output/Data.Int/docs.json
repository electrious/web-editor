{"reExports":[],"name":"Data.Int","comments":null,"declarations":[{"children":[],"comments":"Creates an `Int` from a `Number` value. The number must already be an\ninteger and fall within the valid range of values for the `Int` type\notherwise `Nothing` is returned.\n","title":"fromNumber","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]}},"sourceSpan":{"start":[37,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[37,34]}},{"children":[],"comments":"Convert a `Number` to an `Int`, by taking the closest integer equal to or\ngreater than the argument. Values outside the `Int` range are clamped,\n`NaN` and `Infinity` values return 0.\n","title":"ceil","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[55,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[55,22]}},{"children":[],"comments":"Convert a `Number` to an `Int`, by taking the closest integer equal to or\nless than the argument. Values outside the `Int` range are clamped, `NaN`\nand `Infinity` values return 0.\n","title":"floor","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[49,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[49,23]}},{"children":[],"comments":"Convert a `Number` to an `Int`, by taking the nearest integer to the\nargument. Values outside the `Int` range are clamped, `NaN` and `Infinity`\nvalues return 0.\n","title":"round","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[61,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[61,23]}},{"children":[],"comments":"Converts an `Int` value back into a `Number`. Any `Int` is a valid `Number`\nso there is no loss of precision with this function.\n","title":"toNumber","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[76,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[76,41]}},{"children":[],"comments":"Reads an `Int` from a `String` value. The number must parse as an integer\nand fall within the valid range of values for the `Int` type, otherwise\n`Nothing` is returned.\n","title":"fromString","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]}},"sourceSpan":{"start":[81,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[81,34]}},{"children":[],"comments":"The number of unique digits (including zero) used to represent integers in\na specific base.\n","title":"Radix","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[]},"sourceSpan":{"start":[170,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[170,26]}},{"children":[],"comments":"Create a `Radix` from a number between 2 and 36.\n","title":"radix","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Radix"]}]}]}},"sourceSpan":{"start":[193,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[193,28]}},{"children":[],"comments":"The base-2 system.\n","title":"binary","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Radix"]}},"sourceSpan":{"start":[173,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[173,16]}},{"children":[],"comments":"The base-8 system.\n","title":"octal","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Radix"]}},"sourceSpan":{"start":[177,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[177,15]}},{"children":[],"comments":"The base-10 system.\n","title":"decimal","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Radix"]}},"sourceSpan":{"start":[181,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[181,17]}},{"children":[],"comments":"The base-16 system.\n","title":"hexadecimal","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Radix"]}},"sourceSpan":{"start":[185,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[185,21]}},{"children":[],"comments":"The base-36 system.\n","title":"base36","info":{"declType":"value","type":{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Radix"]}},"sourceSpan":{"start":[189,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[189,16]}},{"children":[],"comments":"Like `fromString`, but the integer can be specified in a different base.\n\nExample:\n``` purs\nfromStringAs binary      \"100\" == Just 4\nfromStringAs hexadecimal \"ff\"  == Just 255\n```\n","title":"fromStringAs","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Radix"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]}]}},"sourceSpan":{"start":[204,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[204,45]}},{"children":[],"comments":null,"title":"toStringAs","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Radix"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}]}},"sourceSpan":{"start":[252,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[252,52]}},{"children":[{"comments":null,"title":"Even","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Odd","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"eqParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[109,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[109,38]}},{"comments":null,"title":"ordParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[110,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[110,40]}},{"comments":null,"title":"showParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Show"],"Show"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[112,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[114,19]}},{"comments":null,"title":"boundedParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Bounded"],"Bounded"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[116,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[118,12]}},{"comments":null,"title":"semiringParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Semiring"],"Semiring"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[120,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[125,17]}},{"comments":null,"title":"ringParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Ring"],"Ring"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[127,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[128,12]}},{"comments":null,"title":"commutativeRingParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","CommutativeRing"],"CommutativeRing"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[130,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[130,57]}},{"comments":null,"title":"euclideanRingParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","EuclideanRing"],"EuclideanRing"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[132,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[136,17]}},{"comments":null,"title":"divisionRingParity","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","DivisionRing"],"DivisionRing"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[138,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[139,19]}}],"comments":"A type for describing whether an integer is even or odd.\n\nThe `Ord` instance considers `Even` to be less than `Odd`.\n\nThe `Semiring` instance allows you to ask about the parity of the results\nof arithmetical operations, given only the parities of the inputs. For\nexample, the sum of an odd number and an even number is odd, so\n`Odd + Even == Odd`. This also works for multiplication, eg. the product\nof two odd numbers is odd, and therefore `Odd * Odd == Odd`.\n\nMore generally, we have that\n\n```purescript\nparity x + parity y == parity (x + y)\nparity x * parity y == parity (x * y)\n```\n\nfor any integers `x`, `y`. (A mathematician would say that `parity` is a\n*ring homomorphism*.)\n\nAfter defining addition and multiplication on `Parity` in this way, the\n`Semiring` laws now force us to choose `zero = Even` and `one = Odd`.\nThis `Semiring` instance actually turns out to be a `Field`.\n","title":"Parity","info":{"declType":"data","dataDeclType":"data","typeArguments":[]},"sourceSpan":{"start":[107,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[107,25]}},{"children":[],"comments":"Returns whether an `Int` is `Even` or `Odd`.\n\n``` purescript\nparity 0 == Even\nparity 1 == Odd\n```\n","title":"parity","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[147,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[147,24]}},{"children":[],"comments":"Returns whether an `Int` is an even number.\n\n``` purescript\neven 0 == true\neven 1 == false\n```\n","title":"even","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}},"sourceSpan":{"start":[156,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[156,23]}},{"children":[],"comments":"The negation of `even`.\n\n``` purescript\nodd 0 == false\nodd 1 == true\n```\n","title":"odd","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}},"sourceSpan":{"start":[165,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[165,22]}},{"children":[],"comments":"The `quot` function provides _truncating_ integer division (see the\ndocumentation for the `EuclideanRing` class). It is identical to `div` in\nthe `EuclideanRing Int` instance if the dividend is positive, but will be\nslightly different if the dividend is negative. For example:\n\n```purescript\ndiv 2 3 == 0\nquot 2 3 == 0\n\ndiv (-2) 3 == (-1)\nquot (-2) 3 == 0\n\ndiv 2 (-3) == 0\nquot 2 (-3) == 0\n```\n","title":"quot","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]}},"sourceSpan":{"start":[222,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[222,41]}},{"children":[],"comments":"The `rem` function provides the remainder after _truncating_ integer\ndivision (see the documentation for the `EuclideanRing` class). It is\nidentical to `mod` in the `EuclideanRing Int` instance if the dividend is\npositive, but will be slightly different if the dividend is negative. For\nexample:\n\n```purescript\nmod 2 3 == 2\nrem 2 3 == 2\n\nmod (-2) 3 == 1\nrem (-2) 3 == (-2)\n\nmod 2 (-3) == 2\nrem 2 (-3) == 2\n```\n","title":"rem","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]}},"sourceSpan":{"start":[240,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[240,40]}},{"children":[],"comments":"Raise an Int to the power of another Int.\n","title":"pow","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]}},"sourceSpan":{"start":[243,1],"name":".spago/integers/v4.0.0/src/Data/Int.purs","end":[243,40]}}]}
// Generated by purs version 0.13.6
"use strict";
var Algorithm_PointInPolygon = require("../Algorithm.PointInPolygon/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Effect = require("../Effect/index.js");
var Math_Angle = require("../Math.Angle/index.js");
var Models_RoofPlate = require("../Models.RoofPlate/index.js");
var RBush_RBush = require("../RBush.RBush/index.js");
var Three_Core_Geometry = require("../Three.Core.Geometry/index.js");
var Three_Core_Mesh = require("../Three.Core.Mesh/index.js");
var Three_Math_Vector = require("../Three.Math.Vector/index.js");
var vertexOffset = 1.0e-4;
var vertexItem = function (point) {
    return function (normal) {
        return function (index) {
            var y = Three_Math_Vector.vecY(Three_Math_Vector.hasYVec3)(point);
            var x = Three_Math_Vector.vecX(Three_Math_Vector.hasXVec3)(point);
            return {
                minX: x - vertexOffset,
                minY: y - vertexOffset,
                maxX: x + vertexOffset,
                maxY: y + vertexOffset,
                vertex: point,
                normal: normal,
                index: index
            };
        };
    };
};
var roofFlattener = function (r) {
    return {
        roofNormal: r.normal,
        roofCenter: r.center,
        roofPolygon: Models_RoofPlate.getRoofPolygon(r)
    };
};
var polygonBoundingBox = function (polygon) {
    var ys = Data_Functor.map(Data_Functor.functorArray)(Three_Math_Vector.vecY(Three_Math_Vector.hasYVec2))(polygon);
    var xs = Data_Functor.map(Data_Functor.functorArray)(Three_Math_Vector.vecX(Three_Math_Vector.hasXVec2))(polygon);
    var minY = Data_Maybe.fromMaybe(0.0)(Data_Foldable.minimum(Data_Ord.ordNumber)(Data_Foldable.foldableArray)(ys));
    var minX = Data_Maybe.fromMaybe(0.0)(Data_Foldable.minimum(Data_Ord.ordNumber)(Data_Foldable.foldableArray)(xs));
    var maxY = Data_Maybe.fromMaybe(0.0)(Data_Foldable.maximum(Data_Ord.ordNumber)(Data_Foldable.foldableArray)(ys));
    var maxX = Data_Maybe.fromMaybe(0.0)(Data_Foldable.maximum(Data_Ord.ordNumber)(Data_Foldable.foldableArray)(xs));
    return {
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY
    };
};
var flatten = function (flattener) {
    return function (v) {
        var nv = Three_Math_Vector.sub(Three_Math_Vector.vecVec3)(flattener.roofCenter)(v);
        var scale = Three_Math_Vector.dot(Three_Math_Vector.vecVec3)(flattener.roofNormal)(nv);
        return Three_Math_Vector.addScaled(Three_Math_Vector.vecVec3)(v)(flattener.roofNormal)(scale);
    };
};
var distToRoof = function (flattener) {
    return function (v) {
        var nv = Three_Math_Vector.sub(Three_Math_Vector.vecVec3)(v)(flattener.roofCenter);
        return Three_Math_Vector.dot(Three_Math_Vector.vecVec3)(flattener.roofNormal)(nv);
    };
};
var flattenRoofplate = function (tree) {
    return function (roof) {
        var flattener = roofFlattener(roof);
        return function __do() {
            var candidates = RBush_RBush.search(polygonBoundingBox(flattener.roofPolygon))(tree)();
            var pointInRoof = function (c) {
                var point = Three_Math_Vector.mkVec2(Three_Math_Vector.vecX(Three_Math_Vector.hasXVec3)(c.vertex))(Three_Math_Vector.vecY(Three_Math_Vector.hasYVec3)(c.vertex));
                return Algorithm_PointInPolygon.pointInPolygon(flattener.roofPolygon)(point);
            };
            var flattenF = function (c) {
                return {
                    index: c.index,
                    newPos: flatten(flattener)(c.vertex)
                };
            };
            var checkDistAndAngle = function (c) {
                var dist = distToRoof(flattener)(c.vertex);
                var angle = Models_RoofPlate.angleBetween(Three_Math_Vector.vecVec3)(flattener.roofNormal)(c.normal);
                return dist < 0.5 && dist >= 0.0 || dist < 0.0 && (dist > -1.0 && Math_Angle.degreeVal(angle) < 20.0);
            };
            var f = function (c) {
                return pointInRoof(c) && checkDistAndAngle(c);
            };
            return Data_Functor.map(Data_Functor.functorArray)(flattenF)(Data_Array.filter(f)(candidates));
        };
    };
};
var buildRTree = function (vertices) {
    return function (normals) {
        var vns = Data_Array.zip(vertices)(normals);
        var nums = Data_Array.range(0)(Data_Array.length(vns) - 1 | 0);
        var f = function (t) {
            return function (idx) {
                return vertexItem(Data_Tuple.fst(t))(Data_Tuple.snd(t))(idx);
            };
        };
        var items = Data_Array.zipWith(f)(vns)(nums);
        return function __do() {
            var tree = RBush_RBush.mkRBush();
            RBush_RBush.load(items)(tree)();
            return tree;
        };
    };
};
var applyFlattenedVertex = function (geo) {
    return function (fvs) {
        return function __do() {
            var newGeo = Three_Core_Geometry.clone(geo)();
            var attr = Three_Core_Geometry.getAttribute("position")(newGeo);
            var $0 = Three_Core_Geometry.isBufferAttribute(attr);
            if ($0) {
                var apply = function (fv) {
                    return Three_Core_Geometry.setXYZ(fv.index)(Three_Math_Vector.vecX(Three_Math_Vector.hasXVec3)(fv.newPos))(Three_Math_Vector.vecY(Three_Math_Vector.hasYVec3)(fv.newPos))(Three_Math_Vector.vecZ(Three_Math_Vector.hasZVec3)(fv.newPos))(attr);
                };
                Data_Foldable.sequence_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(Data_Functor.map(Data_Functor.functorArray)(apply)(fvs))();
                Three_Core_Geometry.setNeedsUpdate(true)(attr)();
                return newGeo;
            };
            return geo;
        };
    };
};
var flattenRoofPlates = function (geo) {
    return function (tree) {
        return function (house) {
            return function (roofs) {
                return function __do() {
                    var fvs = Data_Functor.map(Effect.functorEffect)(Data_Array.concat)(Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(flattenRoofplate(tree))(roofs))();
                    var newGeo = applyFlattenedVertex(geo)(fvs)();
                    return Three_Core_Mesh.setBufferGeometry(newGeo)(house)();
                };
            };
        };
    };
};
module.exports = {
    vertexOffset: vertexOffset,
    vertexItem: vertexItem,
    buildRTree: buildRTree,
    polygonBoundingBox: polygonBoundingBox,
    flatten: flatten,
    distToRoof: distToRoof,
    roofFlattener: roofFlattener,
    applyFlattenedVertex: applyFlattenedVertex,
    flattenRoofplate: flattenRoofplate,
    flattenRoofPlates: flattenRoofPlates
};
